package gobject

/*
[<.CommonIncludes>]

[<.GType>]

[<.CForwardDeclarations>]

[<.GFree>]

#include "gobject.h"

#cgo pkg-config: gobject-2.0
*/
import "C"
import "unsafe"
import "runtime"
import "reflect"

[<.GoUtils>]

[<.GoBindings>]

//--------------------------------------------------------------
// Object
//--------------------------------------------------------------

func (this *Object) GetType() Type {
	return Type(C._g_object_type((*C.GObject)(this.C)))
}

func (this *Object) Connect(signal string, clo interface{}) {
	csignal := C.CString(signal)
	id := nextClosureID()
	ccache.closures[id] = clo
	goclosure := C.g_goclosure_new(C.int32_t(id), _GoInterfaceToCInterface(clo))
	C.g_signal_connect_closure(this.C, csignal, (*C.GClosure)(unsafe.Pointer(goclosure)), 0)
	C.free(unsafe.Pointer(csignal))
}

// closure cache
var ccache = struct {
	values   []reflect.Value
	closures map[int32]interface{}
	id       int32
}{
	make([]reflect.Value, 0, 10),
	make(map[int32]interface{}),
	0,
}

func nextClosureID() int32 {
	id := ccache.id
	ccache.id++
	return id
}

//export g_goclosure_finalize_go
func g_goclosure_finalize_go(goclosure_up unsafe.Pointer) {
	goclosure := (*C.GGoClosure)(goclosure_up)
	delete(ccache.closures, int32(C.g_goclosure_get_id(goclosure)))
}

//export g_goclosure_marshal_go
func g_goclosure_marshal_go(goclosure_up, ret_up unsafe.Pointer, nargs int32, args_up unsafe.Pointer) {
	goclosure := (*C.GGoClosure)(goclosure_up)
	ret := (*Value)(ret_up)
	args := (*(*[alot]Value)(args_up))[:nargs]

	var iface [2]unsafe.Pointer
	C.g_goclosure_get_iface(goclosure, (*unsafe.Pointer)(unsafe.Pointer(&iface)))
	f := reflect.ValueOf(_CInterfaceToGoInterface(iface))
	ft := f.Type()

	ccache.values = ccache.values[:0]
	for i, n := 0, ft.NumIn(); i < n; i++ {
		in := ft.In(i)

		// use default value, if there is not enough args
		if len(args) <= i {
			ccache.values = append(ccache.values, reflect.New(in).Elem())
			continue
		}

		v := ValueToGoValue(&args[i], in)
		ccache.values = append(ccache.values, v)
	}

	out := f.Call(ccache.values)
	if len(out) == 1 {
		ret.SetGo(out[0])
	}
}

//--------------------------------------------------------------
// Type
//--------------------------------------------------------------

type Type C.GType

func (this Type) IsA(other Type) bool {
	return C.g_type_is_a(C.GType(this), C.GType(other)) != 0
}

func (this Type) asC() C.GType {
	return C.GType(this)
}

func GTypeInterface() Type { return Type(C._g_type_interface()) }
func GTypeChar() Type      { return Type(C._g_type_char()) }
func GTypeUChar() Type     { return Type(C._g_type_uchar()) }
func GTypeBoolean() Type   { return Type(C._g_type_boolean()) }
func GTypeInt() Type       { return Type(C._g_type_int()) }
func GTypeUInt() Type      { return Type(C._g_type_uint()) }
func GTypeLong() Type      { return Type(C._g_type_long()) }
func GTypeULong() Type     { return Type(C._g_type_ulong()) }
func GTypeInt64() Type     { return Type(C._g_type_int64()) }
func GTypeUInt64() Type    { return Type(C._g_type_uint64()) }
func GTypeEnum() Type      { return Type(C._g_type_enum()) }
func GTypeFlags() Type     { return Type(C._g_type_flags()) }
func GTypeFloat() Type     { return Type(C._g_type_float()) }
func GTypeDouble() Type    { return Type(C._g_type_double()) }
func GTypeString() Type    { return Type(C._g_type_string()) }
func GTypePointer() Type   { return Type(C._g_type_pointer()) }
func GTypeBoxed() Type     { return Type(C._g_type_boxed()) }
func GTypeParam() Type     { return Type(C._g_type_param()) }
func GTypeObject() Type    { return Type(C._g_type_object()) }
func GTypeGType() Type     { return Type(C._g_type_gtype()) }
func GTypeVariant() Type   { return Type(C._g_type_variant()) }

// Every GObject generated by this generator implements this interface
// and it must work even if the receiver is a nil value
type StaticTyper interface {
	GetStaticType() Type
}

//--------------------------------------------------------------
// Value
//--------------------------------------------------------------

func (this *Value) asC() *C.GValue {
	return (*C.GValue)(unsafe.Pointer(this))
}

// g_value_init
func (this *Value) Init(t Type) {
	C.g_value_init(this.asC(), t.asC())
}

// g_value_copy
func (this *Value) Set(src *Value) {
	C.g_value_copy(src.asC(), this.asC())
}

// g_value_reset
func (this *Value) Reset() {
	C.g_value_reset(this.asC())
}

// g_value_unset
func (this *Value) Unset() {
	C.g_value_unset(this.asC())
}

// G_VALUE_TYPE
func (this *Value) GetType() Type {
	return Type(C._g_value_type(this.asC()))
}

// g_value_type_compatible
func ValueTypeCompatible(src, dst Type) bool {
	return C.g_value_type_compatible(src.asC(), dst.asC()) != 0
}

// g_value_type_transformable
func ValueTypeTransformable(src, dst Type) bool {
	return C.g_value_type_transformable(src.asC(), dst.asC()) != 0
}

// g_value_transform
func (this *Value) Transform(src *Value) bool {
	return C.g_value_transform(src.asC(), this.asC()) != 0
}

// g_value_get_boolean
func (this *Value) GetBool() bool {
	return C.g_value_get_boolean(this.asC()) != 0
}

// g_value_set_boolean
func (this *Value) SetBool(v bool) {
	C.g_value_set_boolean(this.asC(), _GoBoolToCBool(v))
}

// g_value_get_int64
func (this *Value) GetInt() int64 {
	return int64(C.g_value_get_int64(this.asC()))
}

// g_value_set_int64
func (this *Value) SetInt(v int64) {
	C.g_value_set_int64(this.asC(), C.int64_t(v))
}

// g_value_get_uint64
func (this *Value) GetUint() uint64 {
	return uint64(C.g_value_get_uint64(this.asC()))
}

// g_value_set_uint64
func (this *Value) SetUint(v uint64) {
	C.g_value_set_uint64(this.asC(), C.uint64_t(v))
}

// g_value_get_double
func (this *Value) GetFloat() float64 {
	return float64(C.g_value_get_double(this.asC()))
}

// g_value_set_double
func (this *Value) SetFloat(v float64) {
	C.g_value_set_double(this.asC(), C.double(v))
}

// g_value_get_string
func (this *Value) GetString() string {
	return C.GoString((*C.char)(unsafe.Pointer(C.g_value_get_string(this.asC()))))
}

// g_value_take_string
func (this *Value) SetString(v string) {
	cstr := C.CString(v)
	C.g_value_take_string(this.asC(), cstr)
	// not freeing, because GValue takes the ownership
}

// g_value_get_object
func (this *Value) GetObject() unsafe.Pointer {
	return unsafe.Pointer(C.g_value_get_object(this.asC()))
}

//--------------------------------------------------------------
// A giant glue for connecting GType and Go's reflection
//--------------------------------------------------------------

var statictyper = reflect.TypeOf((*StaticTyper)(nil)).Elem()
var objectlike = reflect.TypeOf((*ObjectLike)(nil)).Elem()

func ValueToGoValue(src *Value, t reflect.Type) reflect.Value {
	var out reflect.Value
	var dst Value

	switch t.Kind() {
	case reflect.Bool:
		dst.Init(GTypeBoolean())
		ok := dst.Transform(src)
		if !ok {
			panic("GValue is not transformable to bool")
		}
		out = reflect.New(t)
		out.SetBool(dst.GetBool())
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		dst.Init(GTypeInt64())
		ok := dst.Transform(src)
		if !ok {
			panic("GValue is not transformable to int")
		}
		out = reflect.New(t)
		out.SetInt(dst.GetInt())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		dst.Init(GTypeUInt64())
		ok := dst.Transform(src)
		if !ok {
			panic("GValue is not transformable to uint")
		}
		out = reflect.New(t)
		out.SetUint(dst.GetUint())
	case reflect.Float32, reflect.Float64:
		dst.Init(GTypeDouble())
		ok := dst.Transform(src)
		if !ok {
			panic("GValue is not transformable to float")
		}
		out = reflect.New(t)
		out.SetFloat(dst.GetFloat())
	case reflect.String:
		dst.Init(GTypeString())
		ok := dst.Transform(src)
		if !ok {
			panic("GValue is not transformable to string")
		}
		out = reflect.New(t)
		out.SetString(dst.GetString())
		dst.Unset() // need to clean up in this case
	case reflect.Ptr:
		if t.Implements(objectlike) {
			// at this point we're sure that this is a pointer to the ObjectLike
			out = reflect.New(t.Elem())
			st, ok := out.Interface().(StaticTyper)
			if !ok {
				panic("ObjectLike type must implement StaticTyper as well")
			}
			dst.Init(st.GetStaticType())
			ok = dst.Transform(src)
			if !ok {
				panic("GValue is not transformable to " + t.String())
			}
			obj := (*Object)(unsafe.Pointer(out.Pointer()))
			obj.C = dst.GetObject()
			C.g_object_ref_sink((*C.GObject)(obj.C))
			_SetGObjectFinalizer(obj)
		}
	}
	return out
}

func (this *Value) SetGo(v reflect.Value) {
	var src Value

	switch v.Kind() {
	case reflect.Bool:
		src.Init(GTypeBoolean())
		src.SetBool(v.Bool())
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		src.Init(GTypeInt64())
		src.SetInt(v.Int())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		src.Init(GTypeUInt64())
		src.SetUint(v.Uint())
	case reflect.Float32, reflect.Float64:
		src.Init(GTypeDouble())
		src.SetFloat(v.Float())
	case reflect.String:
		src.Init(GTypeString())
		src.SetString(v.String())
		defer src.Unset() // need to clean up in this case
	case reflect.Ptr:
		// TODO: implement various GObject types here?
	}

	ok := this.Transform(&src)
	if !ok {
		panic("GValue cannot be created from " + v.Kind().String())
	}
}
