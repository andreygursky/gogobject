package gobject

/*
[<.CommonIncludes>]

[<.GType>]

[<.CUtils>]
[<.CForwardDeclarations>]

[<.GFree>]

#include "gobject.h"

extern void g_type_init();
extern void g_value_take_object(GValue*, void*);

#cgo pkg-config: gobject-2.0
*/
import "C"
import "unsafe"
import "runtime"
import "reflect"

[<.GoUtils>]

[<.GoBindings>]

//--------------------------------------------------------------
// Object
//--------------------------------------------------------------

func (this *Object) GetType() Type {
	return Type(C._g_object_type((*C.GObject)(this.C)))
}

func (this *Object) Connect(signal string, clo interface{}) {
	csignal := C.CString(signal)
	id := nextClosureID()
	ccache.closures[id] = clo
	goclosure := C.g_goclosure_new(C.int32_t(id), _GoInterfaceToCInterface(clo))
	C.g_signal_connect_closure(this.C, csignal, (*C.GClosure)(unsafe.Pointer(goclosure)), 0)
	C.free(unsafe.Pointer(csignal))
}

// closure cache
var ccache = struct {
	values   []reflect.Value
	closures map[int32]interface{}
	id       int32
}{
	make([]reflect.Value, 0, 10),
	make(map[int32]interface{}),
	0,
}

func nextClosureID() int32 {
	id := ccache.id
	ccache.id++
	return id
}

//export g_goclosure_finalize_go
func g_goclosure_finalize_go(goclosure_up unsafe.Pointer) {
	goclosure := (*C.GGoClosure)(goclosure_up)
	delete(ccache.closures, int32(C.g_goclosure_get_id(goclosure)))
}

//export g_goclosure_marshal_go
func g_goclosure_marshal_go(goclosure_up, ret_up unsafe.Pointer, nargs int32, args_up unsafe.Pointer) {
	goclosure := (*C.GGoClosure)(goclosure_up)
	ret := (*Value)(ret_up)
	args := (*(*[alot]Value)(args_up))[:nargs]

	var iface [2]unsafe.Pointer
	C.g_goclosure_get_iface(goclosure, (*unsafe.Pointer)(unsafe.Pointer(&iface)))
	f := reflect.ValueOf(_CInterfaceToGoInterface(iface))
	ft := f.Type()

	ccache.values = ccache.values[:0]
	for i, n := 0, ft.NumIn(); i < n; i++ {
		in := ft.In(i)

		// use default value, if there is not enough args
		if len(args) <= i {
			ccache.values = append(ccache.values, reflect.New(in).Elem())
			continue
		}

		v := args[i].GetGoValue(in)
		ccache.values = append(ccache.values, v)
	}

	out := f.Call(ccache.values)
	if len(out) == 1 {
		ret.SetGoValue(out[0])
	}
}

//--------------------------------------------------------------
// Go Interface boxed type
//--------------------------------------------------------------

var _boxedcache = make(map[unsafe.Pointer]int)

//export g_go_interface_copy_go
func g_go_interface_copy_go(boxed unsafe.Pointer) unsafe.Pointer {
	count, ok := _boxedcache[boxed]
	if !ok {
		panic("Trying to copy a boxed type that is not in the cache")
	}

	_boxedcache[boxed] = count + 1
	return boxed
}

//export g_go_interface_free_go
func g_go_interface_free_go(boxed unsafe.Pointer) {
	count, ok := _boxedcache[boxed]
	if !ok {
		panic("Trying to delete a boxed type that is not in the cache")
	}

	if count == 1 {
		delete(_boxedcache, boxed)
	} else {
		_boxedcache[boxed] = count - 1
	}
}

//--------------------------------------------------------------
// Type
//--------------------------------------------------------------

type Type C.GType

func (this Type) IsA(other Type) bool {
	return C.g_type_is_a(C.GType(this), C.GType(other)) != 0
}

func (this Type) String() string {
	cname := C.g_type_name(C.GType(this))
	if cname == nil {
		return ""
	}
	return C.GoString(cname)
}

func (this Type) asC() C.GType {
	return C.GType(this)
}

var (
	Interface Type
	Char Type
	UChar Type
	Boolean Type
	Int Type
	UInt Type
	Long Type
	ULong Type
	Int64 Type
	UInt64 Type
	Enum Type
	Flags Type
	Float Type
	Double Type
	String Type
	Pointer Type
	Boxed Type
	Param Type
	GObject Type
	GType Type
	Variant Type
	GoInterface Type
)

func init() {
	C.g_type_init()

	Interface = Type(C._g_type_interface())
	Char = Type(C._g_type_char())
	UChar = Type(C._g_type_uchar())
	Boolean = Type(C._g_type_boolean())
	Int = Type(C._g_type_int())
	UInt = Type(C._g_type_uint())
	Long = Type(C._g_type_long())
	ULong = Type(C._g_type_ulong())
	Int64 = Type(C._g_type_int64())
	UInt64 = Type(C._g_type_uint64())
	Enum = Type(C._g_type_enum())
	Flags = Type(C._g_type_flags())
	Float = Type(C._g_type_float())
	Double = Type(C._g_type_double())
	String = Type(C._g_type_string())
	Pointer = Type(C._g_type_pointer())
	Boxed = Type(C._g_type_boxed())
	Param = Type(C._g_type_param())
	GObject = Type(C._g_type_object())
	GType = Type(C._g_type_gtype())
	Variant = Type(C._g_type_variant())
	GoInterface = Type(C._g_type_go_interface())
}

// Every GObject generated by this generator implements this interface
// and it must work even if the receiver is a nil value
type StaticTyper interface {
	GetStaticType() Type
}

//--------------------------------------------------------------
// Value
//--------------------------------------------------------------

func (this *Value) asC() *C.GValue {
	return (*C.GValue)(unsafe.Pointer(this))
}

// g_value_init
func (this *Value) Init(t Type) {
	C.g_value_init(this.asC(), t.asC())
}

// g_value_copy
func (this *Value) Set(src *Value) {
	C.g_value_copy(src.asC(), this.asC())
}

// g_value_reset
func (this *Value) Reset() {
	C.g_value_reset(this.asC())
}

// g_value_unset
func (this *Value) Unset() {
	C.g_value_unset(this.asC())
}

// G_VALUE_TYPE
func (this *Value) GetType() Type {
	return Type(C._g_value_type(this.asC()))
}

// g_value_type_compatible
func ValueTypeCompatible(src, dst Type) bool {
	return C.g_value_type_compatible(src.asC(), dst.asC()) != 0
}

// g_value_type_transformable
func ValueTypeTransformable(src, dst Type) bool {
	return C.g_value_type_transformable(src.asC(), dst.asC()) != 0
}

// g_value_transform
func (this *Value) Transform(src *Value) bool {
	return C.g_value_transform(src.asC(), this.asC()) != 0
}

// g_value_get_boolean
func (this *Value) GetBool() bool {
	return C.g_value_get_boolean(this.asC()) != 0
}

// g_value_set_boolean
func (this *Value) SetBool(v bool) {
	C.g_value_set_boolean(this.asC(), _GoBoolToCBool(v))
}

// g_value_get_int64
func (this *Value) GetInt() int64 {
	return int64(C.g_value_get_int64(this.asC()))
}

// g_value_set_int64
func (this *Value) SetInt(v int64) {
	C.g_value_set_int64(this.asC(), C.int64_t(v))
}

// g_value_get_uint64
func (this *Value) GetUint() uint64 {
	return uint64(C.g_value_get_uint64(this.asC()))
}

// g_value_set_uint64
func (this *Value) SetUint(v uint64) {
	C.g_value_set_uint64(this.asC(), C.uint64_t(v))
}

// g_value_get_double
func (this *Value) GetFloat() float64 {
	return float64(C.g_value_get_double(this.asC()))
}

// g_value_set_double
func (this *Value) SetFloat(v float64) {
	C.g_value_set_double(this.asC(), C.double(v))
}

// g_value_get_string
func (this *Value) GetString() string {
	return C.GoString(C.g_value_get_string(this.asC()))
}

// g_value_take_string
func (this *Value) SetString(v string) {
	cstr := C.CString(v)
	C.g_value_take_string(this.asC(), cstr)
	// not freeing, because GValue takes the ownership
}

// g_value_get_object
func (this *Value) GetObject() unsafe.Pointer {
	return unsafe.Pointer(C.g_value_get_object(this.asC()))
}

// g_value_take_object
func (this *Value) SetObject(x unsafe.Pointer) {
	C.g_value_take_object(this.asC(), x)
}

//--------------------------------------------------------------
// A giant glue for connecting GType and Go's reflection
//--------------------------------------------------------------

var statictyper = reflect.TypeOf((*StaticTyper)(nil)).Elem()
var objectlike = reflect.TypeOf((*ObjectLike)(nil)).Elem()

func (this *Value) SetGoValue(v reflect.Value) {
	valuetype := this.GetType()
	var src Value

	transform := func() {
		ok := this.Transform(&src)
		if !ok {
			panic("Go value is not transformable to " + valuetype.String())
		}
	}

	switch v.Kind() {
	case reflect.Bool:
		src.Init(Boolean)
		src.SetBool(v.Bool())
		transform()
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		src.Init(Int64)
		src.SetInt(v.Int())
		transform()
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		src.Init(UInt64)
		src.SetUint(v.Uint())
		transform()
	case reflect.Float32, reflect.Float64:
		src.Init(Double)
		src.SetFloat(v.Float())
		transform()
	case reflect.String:
		src.Init(String)
		src.SetString(v.String())
		transform()
		src.Unset()
	case reflect.Ptr:
		gotype := v.Type()
		src.Init(GObject)
		if gotype.Implements(objectlike) {
			obj, ok := v.Interface().(ObjectLike)
			if !ok {
				panic(gotype.String() + " is not transformable to GValue")
			}

			src.SetObject(unsafe.Pointer(obj.InheritedFromGObject()))
			transform()
		}
		src.Unset()
	}
}

func (this *Value) GetGoValue(t reflect.Type) reflect.Value {
	var out reflect.Value
	var dst Value

	transform := func() {
		ok := dst.Transform(this)
		if !ok {
			panic("GValue is not transformable to " + t.String())
		}
	}

	switch t.Kind() {
	case reflect.Bool:
		dst.Init(Boolean)
		transform()
		out = reflect.New(t).Elem()
		out.SetBool(dst.GetBool())
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		dst.Init(Int64)
		transform()
		out = reflect.New(t).Elem()
		out.SetInt(dst.GetInt())
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		dst.Init(UInt64)
		transform()
		out = reflect.New(t).Elem()
		out.SetUint(dst.GetUint())
	case reflect.Float32, reflect.Float64:
		dst.Init(Double)
		transform()
		out = reflect.New(t).Elem()
		out.SetFloat(dst.GetFloat())
	case reflect.String:
		dst.Init(String)
		transform()
		out = reflect.New(t).Elem()
		out.SetString(dst.GetString())
		dst.Unset() // need to clean up in this case
	case reflect.Ptr:
		if t.Implements(objectlike) {
			// at this point we're sure that this is a pointer to the ObjectLike
			out = reflect.New(t.Elem())
			st, ok := out.Interface().(StaticTyper)
			if !ok {
				panic("ObjectLike type must implement StaticTyper as well")
			}
			dst.Init(st.GetStaticType())
			transform()
			obj := (*Object)(unsafe.Pointer(out.Pointer()))
			obj.C = dst.GetObject()
			C.g_object_ref_sink((*C.GObject)(obj.C))
			_SetGObjectFinalizer(obj)
		}
	}
	return out
}

func (this *Value) SetGoInterface(v interface{}) {
	this.SetGoValue(reflect.ValueOf(v))
}
